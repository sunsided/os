(function() {
    var type_impls = Object.fromEntries([["kernel",[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Vmm%3C'm,+M,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/kernel_alloc/vmm.rs.html#61\">Source</a><a href=\"#impl-Vmm%3C'm,+M,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'m, M, A&gt; <a class=\"struct\" href=\"kernel_alloc/vmm/struct.Vmm.html\" title=\"struct kernel_alloc::vmm::Vmm\">Vmm</a>&lt;'m, M, A&gt;<div class=\"where\">where\n    M: <a class=\"trait\" href=\"kernel_vmem/trait.PhysMapper.html\" title=\"trait kernel_vmem::PhysMapper\">PhysMapper</a>,\n    A: <a class=\"trait\" href=\"kernel_vmem/trait.PhysFrameAlloc.html\" title=\"trait kernel_vmem::PhysFrameAlloc\">PhysFrameAlloc</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_current\" class=\"method\"><a class=\"src rightside\" href=\"src/kernel_alloc/vmm.rs.html#65\">Source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"kernel_alloc/vmm/struct.Vmm.html#tymethod.from_current\" class=\"fn\">from_current</a>(mapper: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.reference.html\">&amp;'m M</a>, alloc: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.reference.html\">&amp;'m mut A</a>) -&gt; <a class=\"struct\" href=\"kernel_alloc/vmm/struct.Vmm.html\" title=\"struct kernel_alloc::vmm::Vmm\">Vmm</a>&lt;'m, M, A&gt;</h4></section></summary><div class=\"docblock\"><h5 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">§</a>Safety</h5>\n<ul>\n<li>Must run at CPL0 with paging enabled.</li>\n<li>Assumes CR3 points at a valid PML4 frame.</li>\n</ul>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clear_lower_half\" class=\"method\"><a class=\"src rightside\" href=\"src/kernel_alloc/vmm.rs.html#77\">Source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"kernel_alloc/vmm/struct.Vmm.html#tymethod.clear_lower_half\" class=\"fn\">clear_lower_half</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><h5 id=\"safety-1\"><a class=\"doc-anchor\" href=\"#safety-1\">§</a>Safety</h5>\n<p>This completely unmaps all lower-half PML4 records of the page table\nwithout walking, nor actively unmapping PDPT, PD and PT records. This\nis meant to be used exactly once after the kernel is set up, and never again.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.query\" class=\"method\"><a class=\"src rightside\" href=\"src/kernel_alloc/vmm.rs.html#83\">Source</a><h4 class=\"code-header\">pub fn <a href=\"kernel_alloc/vmm/struct.Vmm.html#tymethod.query\" class=\"fn\">query</a>(&amp;self, va: <a class=\"struct\" href=\"kernel_memory_addresses/virtual_address/struct.VirtualAddress.html\" title=\"struct kernel_memory_addresses::virtual_address::VirtualAddress\">VirtualAddress</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"kernel_memory_addresses/physical_address/struct.PhysicalAddress.html\" title=\"struct kernel_memory_addresses::physical_address::PhysicalAddress\">PhysicalAddress</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Translate VA→PA if mapped (handles 1G/2M/4K leaves with offset).</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.map_one\" class=\"method\"><a class=\"src rightside\" href=\"src/kernel_alloc/vmm.rs.html#89-96\">Source</a><h4 class=\"code-header\">pub fn <a href=\"kernel_alloc/vmm/struct.Vmm.html#tymethod.map_one\" class=\"fn\">map_one</a>&lt;S&gt;(\n    &amp;mut self,\n    target: <a class=\"enum\" href=\"kernel_alloc/vmm/enum.AllocationTarget.html\" title=\"enum kernel_alloc::vmm::AllocationTarget\">AllocationTarget</a>,\n    va: <a class=\"struct\" href=\"kernel_memory_addresses/virtual_address/struct.VirtualAddress.html\" title=\"struct kernel_memory_addresses::virtual_address::VirtualAddress\">VirtualAddress</a>,\n    pa: <a class=\"struct\" href=\"kernel_memory_addresses/physical_address/struct.PhysicalAddress.html\" title=\"struct kernel_memory_addresses::physical_address::PhysicalAddress\">PhysicalAddress</a>,\n    nonleaf_flags: <a class=\"struct\" href=\"kernel_vmem/bits/struct.VirtualMemoryPageBits.html\" title=\"struct kernel_vmem::bits::VirtualMemoryPageBits\">VirtualMemoryPageBits</a>,\n    leaf_flags: <a class=\"struct\" href=\"kernel_vmem/bits/struct.VirtualMemoryPageBits.html\" title=\"struct kernel_vmem::bits::VirtualMemoryPageBits\">VirtualMemoryPageBits</a>,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.unit.html\">()</a>, <a class=\"enum\" href=\"kernel_vmem/address_space/enum.AddressSpaceMapOneError.html\" title=\"enum kernel_vmem::address_space::AddressSpaceMapOneError\">AddressSpaceMapOneError</a>&gt;<div class=\"where\">where\n    S: <a class=\"trait\" href=\"kernel_vmem/address_space/map_size/trait.MapSize.html\" title=\"trait kernel_vmem::address_space::map_size::MapSize\">MapSize</a>,</div></h4></section></summary><div class=\"docblock\"><p>Map <strong>one</strong> page of size <code>S</code> with <code>leaf_flags</code>, creating parents with <code>nonleaf_flags</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.unmap_one_4k\" class=\"method\"><a class=\"src rightside\" href=\"src/kernel_alloc/vmm.rs.html#104\">Source</a><h4 class=\"code-header\">pub fn <a href=\"kernel_alloc/vmm/struct.Vmm.html#tymethod.unmap_one_4k\" class=\"fn\">unmap_one_4k</a>(&amp;mut self, va: <a class=\"struct\" href=\"kernel_memory_addresses/virtual_address/struct.VirtualAddress.html\" title=\"struct kernel_memory_addresses::virtual_address::VirtualAddress\">VirtualAddress</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.unit.html\">()</a>, &amp;'static <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.str.html\">str</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Unmap a single <strong>4 KiB</strong> page at <code>va</code>. Returns Err if not a 4K mapping.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.map_region\" class=\"method\"><a class=\"src rightside\" href=\"src/kernel_alloc/vmm.rs.html#113-121\">Source</a><h4 class=\"code-header\">pub fn <a href=\"kernel_alloc/vmm/struct.Vmm.html#tymethod.map_region\" class=\"fn\">map_region</a>(\n    &amp;mut self,\n    target: <a class=\"enum\" href=\"kernel_alloc/vmm/enum.AllocationTarget.html\" title=\"enum kernel_alloc::vmm::AllocationTarget\">AllocationTarget</a>,\n    va: <a class=\"struct\" href=\"kernel_memory_addresses/virtual_address/struct.VirtualAddress.html\" title=\"struct kernel_memory_addresses::virtual_address::VirtualAddress\">VirtualAddress</a>,\n    pa: <a class=\"struct\" href=\"kernel_memory_addresses/physical_address/struct.PhysicalAddress.html\" title=\"struct kernel_memory_addresses::physical_address::PhysicalAddress\">PhysicalAddress</a>,\n    len: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.u64.html\">u64</a>,\n    nonleaf: <a class=\"struct\" href=\"kernel_vmem/bits/struct.VirtualMemoryPageBits.html\" title=\"struct kernel_vmem::bits::VirtualMemoryPageBits\">VirtualMemoryPageBits</a>,\n    leaf: <a class=\"struct\" href=\"kernel_vmem/bits/struct.VirtualMemoryPageBits.html\" title=\"struct kernel_vmem::bits::VirtualMemoryPageBits\">VirtualMemoryPageBits</a>,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.unit.html\">()</a>, <a class=\"enum\" href=\"kernel_alloc/vmm/enum.VmmError.html\" title=\"enum kernel_alloc::vmm::VmmError\">VmmError</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Greedy region map: tiles <code>[va .. va+len)</code> to <code>[pa .. pa+len)</code> with 1G/2M/4K leaves.</p>\n<h5 id=\"errors\"><a class=\"doc-anchor\" href=\"#errors\">§</a>Errors</h5>\n<p>Allocation fails, e.g. due to OOM.</p>\n</div></details><section id=\"method.unmap_region\" class=\"method\"><a class=\"src rightside\" href=\"src/kernel_alloc/vmm.rs.html#128\">Source</a><h4 class=\"code-header\">pub fn <a href=\"kernel_alloc/vmm/struct.Vmm.html#tymethod.unmap_region\" class=\"fn\">unmap_region</a>(&amp;mut self, va: <a class=\"struct\" href=\"kernel_memory_addresses/virtual_address/struct.VirtualAddress.html\" title=\"struct kernel_memory_addresses::virtual_address::VirtualAddress\">VirtualAddress</a>, len: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.u64.html\">u64</a>)</h4></section><details class=\"toggle method-toggle\" open><summary><section id=\"method.map_anon_4k_pages\" class=\"method\"><a class=\"src rightside\" href=\"src/kernel_alloc/vmm.rs.html#136-144\">Source</a><h4 class=\"code-header\">pub fn <a href=\"kernel_alloc/vmm/struct.Vmm.html#tymethod.map_anon_4k_pages\" class=\"fn\">map_anon_4k_pages</a>(\n    &amp;mut self,\n    target: <a class=\"enum\" href=\"kernel_alloc/vmm/enum.AllocationTarget.html\" title=\"enum kernel_alloc::vmm::AllocationTarget\">AllocationTarget</a>,\n    va_start: <a class=\"struct\" href=\"kernel_memory_addresses/virtual_address/struct.VirtualAddress.html\" title=\"struct kernel_memory_addresses::virtual_address::VirtualAddress\">VirtualAddress</a>,\n    guard: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.u64.html\">u64</a>,\n    bytes: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.u64.html\">u64</a>,\n    nonleaf: <a class=\"struct\" href=\"kernel_vmem/bits/struct.VirtualMemoryPageBits.html\" title=\"struct kernel_vmem::bits::VirtualMemoryPageBits\">VirtualMemoryPageBits</a>,\n    leaf: <a class=\"struct\" href=\"kernel_vmem/bits/struct.VirtualMemoryPageBits.html\" title=\"struct kernel_vmem::bits::VirtualMemoryPageBits\">VirtualMemoryPageBits</a>,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.unit.html\">()</a>, <a class=\"enum\" href=\"kernel_alloc/vmm/enum.VmmError.html\" title=\"enum kernel_alloc::vmm::VmmError\">VmmError</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Convenience: map a <strong>per-page</strong> region using freshly allocated 4K frames (no PA contiguity).</p>\n<p>Leaves <code>guard</code> bytes at the beginning <strong>unmapped</strong> (for stacks).</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.copy_to_mapped_user\" class=\"method\"><a class=\"src rightside\" href=\"src/kernel_alloc/vmm.rs.html#171-175\">Source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"kernel_alloc/vmm/struct.Vmm.html#tymethod.copy_to_mapped_user\" class=\"fn\">copy_to_mapped_user</a>(\n    &amp;mut self,\n    dst_user: <a class=\"struct\" href=\"kernel_memory_addresses/virtual_address/struct.VirtualAddress.html\" title=\"struct kernel_memory_addresses::virtual_address::VirtualAddress\">VirtualAddress</a>,\n    src: &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.u8.html\">u8</a>],\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.unit.html\">()</a>, <a class=\"enum\" href=\"kernel_alloc/vmm/enum.VmmError.html\" title=\"enum kernel_alloc::vmm::VmmError\">VmmError</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Copy a kernel slice into an already <strong>mapped</strong> user region.</p>\n<h5 id=\"safety-2\"><a class=\"doc-anchor\" href=\"#safety-2\">§</a>Safety</h5>\n<ul>\n<li><code>dst_user .. dst_user+src.len()</code> must be mapped and writable.</li>\n<li>Same address space active (your current setup).</li>\n</ul>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.make_region_rx\" class=\"method\"><a class=\"src rightside\" href=\"src/kernel_alloc/vmm.rs.html#207-213\">Source</a><h4 class=\"code-header\">pub fn <a href=\"kernel_alloc/vmm/struct.Vmm.html#tymethod.make_region_rx\" class=\"fn\">make_region_rx</a>(\n    &amp;mut self,\n    va_start: <a class=\"struct\" href=\"kernel_memory_addresses/virtual_address/struct.VirtualAddress.html\" title=\"struct kernel_memory_addresses::virtual_address::VirtualAddress\">VirtualAddress</a>,\n    len: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.u64.html\">u64</a>,\n    nonleaf: <a class=\"struct\" href=\"kernel_vmem/bits/struct.VirtualMemoryPageBits.html\" title=\"struct kernel_vmem::bits::VirtualMemoryPageBits\">VirtualMemoryPageBits</a>,\n    leaf_rx: <a class=\"struct\" href=\"kernel_vmem/bits/struct.VirtualMemoryPageBits.html\" title=\"struct kernel_vmem::bits::VirtualMemoryPageBits\">VirtualMemoryPageBits</a>,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.unit.html\">()</a>, <a class=\"enum\" href=\"kernel_alloc/vmm/enum.VmmError.html\" title=\"enum kernel_alloc::vmm::VmmError\">VmmError</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Change per-page protection from RW to RX by unmapping &amp; remapping with the same PA.\nWorks for 4K pages created by <code>map_anon_4k_pages</code>.v</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.invlpg\" class=\"method\"><a class=\"src rightside\" href=\"src/kernel_alloc/vmm.rs.html#254\">Source</a><h4 class=\"code-header\">pub fn <a href=\"kernel_alloc/vmm/struct.Vmm.html#tymethod.invlpg\" class=\"fn\">invlpg</a>(&amp;self, page: <a class=\"struct\" href=\"kernel_memory_addresses/virtual_page/struct.VirtualPage.html\" title=\"struct kernel_memory_addresses::virtual_page::VirtualPage\">VirtualPage</a>&lt;<a class=\"struct\" href=\"kernel_memory_addresses/page_size/struct.Size4K.html\" title=\"struct kernel_memory_addresses::page_size::Size4K\">Size4K</a>&gt;)</h4></section></summary><div class=\"docblock\"><p>Invalidate one VA on this CPU (when you modified the active address space).</p>\n<p>Calls <a href=\"kernel_vmem/fn.invalidate_tlb_page.html\" title=\"fn kernel_vmem::invalidate_tlb_page\"><code>invalidate_tlb_page</code></a> for the given 4 KiB page in the <strong>current</strong>\naddress space (the CR3 that is active on this CPU).</p>\n<h5 id=\"safety-correctness-requirements\"><a class=\"doc-anchor\" href=\"#safety-correctness-requirements\">§</a>Safety (correctness requirements)</h5>\n<p>This method is safe to call, but you must ensure the following for it to\nactually produce correct behavior:</p>\n<ul>\n<li>You <strong>only</strong> use it after modifying the <strong>currently active</strong> page tables\n(same CR3/PCID that the calling CPU is running under). Invalidating a VA\nfor a different CR3 does nothing for that other address space.</li>\n<li>It affects <strong>only the calling CPU</strong>. On SMP systems you must also issue\ninvalidations (e.g., via IPIs) on any CPU that might have cached the old\ntranslation.</li>\n<li>With PCID and/or global pages enabled, this invalidation might not cover\nall translations you expect. Use an appropriate scheme (e.g., INVPCID or\nCR4.PGE toggling) if your paging mode relies on those features.</li>\n</ul>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.local_tlb_flush_all\" class=\"method\"><a class=\"src rightside\" href=\"src/kernel_alloc/vmm.rs.html#280\">Source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"kernel_alloc/vmm/struct.Vmm.html#tymethod.local_tlb_flush_all\" class=\"fn\">local_tlb_flush_all</a>(&amp;self)</h4></section></summary><div class=\"docblock\"><p>Flushes the (non-global) TLB entries for the <strong>current address space</strong> on this CPU\nby reloading CR3 with its current value.</p>\n<p>On <code>x86/x86_64</code>, <code>mov cr3, cr3</code> invalidates cached translations associated with the\nactive CR3/PCID on the <strong>local CPU</strong>. It does <strong>not</strong> invalidate global mappings.</p>\n<h5 id=\"safety-3\"><a class=\"doc-anchor\" href=\"#safety-3\">§</a>Safety</h5>\n<p>Calling this is <code>unsafe</code> because misuse can corrupt memory or hang the system.\nThe caller must guarantee:</p>\n<ul>\n<li><strong>Privilege:</strong> Running in a context where CR3 access is permitted (e.g., ring 0).</li>\n<li><strong>Address space intent:</strong> You intend to flush the <strong>current</strong> CR3/PCID only.\nOther address spaces are unaffected.</li>\n<li><strong>Global mappings:</strong> This does <strong>not</strong> flush global (PGE) entries. If you rely\non global mappings, use an alternative strategy (e.g., clear/set CR4.PGE or use\nINVPCID where available).</li>\n<li><strong>PCID semantics:</strong> With PCID enabled, this flush targets the active PCID only.\nEnsure that matches your invalidation intent.</li>\n<li><strong>SMP:</strong> It affects <strong>only</strong> the calling CPU. Coordinate remote TLB shootdowns\n(e.g., via IPIs) for other CPUs that could have cached stale entries.</li>\n<li><strong>Concurrency:</strong> Ensure that other cores/interrupts can’t concurrently depend\non the stale translations you’re invalidating (disable interrupts or otherwise\nsynchronize as appropriate).</li>\n</ul>\n</div></details></div></details>",0,"kernel::alloc::KernelVmm"]]]]);
    if (window.register_type_impls) {
        window.register_type_impls(type_impls);
    } else {
        window.pending_type_impls = type_impls;
    }
})()
//{"start":55,"fragment_lengths":[18281]}