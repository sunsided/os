rd_("CaReached PT (L1) with its index and current entry.BnFramebuffer information, passed from UEFI GOP.Aox86-64 Page Directory (PD / L2)Akx86-64 Page Table (PT / L1)DiUEFI <code>PixelFormat::Bgr</code> \xe2\x80\x94 8:8:8 (or bitmask-equivalent), \xe2\x80\xa6FiL2 <strong>PDE</strong> \xe2\x80\x94 pointer to a <strong>Page Table</strong> (non-leaf; PS <strong>= 0</strong>).DiUEFI <code>PixelFormat::Rgb</code> \xe2\x80\x94 8:8:8 (or bitmask-equivalent), \xe2\x80\xa6BfMinimal kernel virtual memory manager.AaELF file handlingBaRead the entry at <code>i</code>.B`Read an entry at <code>i</code>.BbRead the entry at the given index.2CbCreate a new spinlock wrapping <code>inner</code>.DiCreate from a raw value, asserting it is &lt; <code>S::SIZE</code> in \xe2\x80\xa6BkCreates a new default initialized bitfield.0BfConstruct from a raw <code>u16</code>.1101BoConstruct an index from a raw <code>u16</code>.212BbWrite the entry at <code>i</code>.BaWrite an entry at <code>i</code>.BcWrite the entry at the given index.2CdMinimal Virtual Memory Manager (VMM) for the kernel.BoACPI 1.0 Root System Description Pointer (RSDP)BbPage size in bytes (power of two).CcACPI 2.0 Extended System Description Pointer (XSDP)BnReturn the base as <code>MemoryAddress</code>.B`Raw 64-bit storage of the entry.0AhKerrnel Boot InformationAoReturns the argument unchanged.000000000000000000000000000000000000CmBuild an index from a canonical virtual address (extracts \xe2\x80\xa61111110111CjConstruct an index from a canonical virtual address by \xe2\x80\xa62221222222222222BcRe-export constants as info module.BaCalls <code>U::from(self)</code>.000000000000000000000000000000000000000000000000000000000000BnCombine with an offset to form a full address.DhDecode the entry into its semantic kind, or <code>None</code> if not \xe2\x80\xa60AgMemory map information.DkThe page for size <code>S</code> that contains this address (lower bits \xe2\x80\xa6Box86-64 Page Directory Pointer Table (PDPT / L3)Anx86-64 Page Map Level 4 (PML4)jBits: 2..3CdRSDP/XSDP (Root/Extended System Description Pointer)BhRoot/Extended System Description PointerDm<strong>User/Supervisor</strong> (US): user-mode access if <code>true</code>.0mUser (bit 2).0BfUser (bit 2): user-mode access if set.1Dh<strong>User/Supervisor</strong> (bit 2): allow user-mode access if set.2Dl<strong>Typed read-only view</strong> chosen by the <strong>PS</strong> bit.0CgVirtual Memory Setup for Kernel loading (new typed API)ChInternal walker: resolves VA to the point it terminates.BbCreate a zero (non-present) entry.0ChCreate a zero (non-present) entry with all bits cleared.1AiNon-leaf PDE view (PS=0).AkNon-leaf PDPTE view (PS=0).EhL2 <strong>PDE (2 MiB leaf)</strong> \xe2\x80\x94 maps a single 2 MiB page (<code>PS = 1</code>).G`L3 <strong>PDPTE</strong> \xe2\x80\x94 pointer to a <strong>Page Directory</strong> (non-leaf; PS <strong>= 0</strong>\xe2\x80\xa6Cilog2(SIZE), i.e., number of low bits used for the offset.Cf<strong>Dirty</strong> (D): set by CPU on first write.0Dk<strong>Dirty</strong> (bit 6): set by CPU on first write to this 2 MiB \xe2\x80\xa6Dk<strong>Dirty</strong> (bit 6): set by CPU on first write to this 1 GiB \xe2\x80\xa6BiDirty (bit 6): set by CPU on first write.BlNon-leaf form: next-level Page Table (PS=0).C`Non-leaf form: next-level Page Directory (PS=0).CoELF <code>p_flags</code> (<code>PF_X</code>, <code>PF_W</code>)AdThe protected value.CaValidate the RSDP/XSDP from the physical address.EbTranslate a <code>VirtualAddress</code> to <code>PhysicalAddress</code> if mapped.EiSplit into (<code>MemoryPage&lt;S&gt;</code>, <code>MemoryAddressOffset&lt;S&gt;</code>).jBits: 1..2Bn<strong>Borrowed view</strong> into an L2 PDE.C`<strong>Borrowed view</strong> into an L3 PDPTE.AiHit a 1 GiB leaf at PDPT.Am1 GiB leaf PDPTE view (PS=1).AgHit a 2 MiB leaf at PD.Ak2 MiB leaf PDE view (PS=1).CiPhysical Memory mapper for the Higher-Half Direct Map \xe2\x80\xa6CmBitfield wrapper for <code>Elf64_Phdr.p_flags</code> (32-bit)DnHardware <strong>Page Size</strong> (PS) bit position shared across levels \xe2\x80\xa6Bn1 GiB page (<code>1_073_741_824</code> bytes).Bj2 MiB page (<code>2_097_152</code> bytes).Ah4 KiB page (4096 bytes).Dg<strong>Global</strong> (G): TLB not flushed on CR3 reload (leaf only).0De<strong>Global</strong> (bit 8): TLB entry not flushed on CR3 reload.0CdGlobal (bit 8): TLB entry not flushed on CR3 reload.AbKernel Entry PointAbELF Segment LoaderDgLock state (<code>false</code> = unlocked, <code>true</code> = locked).fSafetymMemory LayoutDhThe offset within the page of size <code>S</code> that contains this \xe2\x80\xa6AbELF Header ParsingDgBorrow a <code>PageDirectory</code> (PD) located in the given 4 KiB \xe2\x80\xa6CfBorrow a <code>PageDirectory</code> (PD) in this frameDcBorrow a <code>PageTable</code> (PT) located in the given 4 KiB \xe2\x80\xa6CcBorrow a <code>PageTable</code> (PT) in this frame.DgSealed trait pattern to restrict <code>PageSize</code> impls to our \xe2\x80\xa6E`Sets the provided <code>PageDirectory</code> at the specified <code>page</code>.DlSets the provided <code>PageTable</code> at the specified <code>page</code>.BhEncode into <code>Pde</code> (non-leaf).CeCreate a fully zeroed Page Directory (all entries \xe2\x80\xa6CeCreate a fully zeroed PDPT (all entries non-present).CkCreate a fully zeroed (all entries non-present) PML4 table.CkCreate a fully zeroed Page Table (all entries non-present).Ae16-byte aligned stackDeUEFI <code>PixelFormat::Bitmask(mask)</code> \xe2\x80\x94 see the masks in \xe2\x80\xa6EeUEFI <code>PixelFormat::BltOnly</code> \xe2\x80\x94 <strong>no linear framebuffer </strong>\xe2\x80\xa6CcYou will write a <strong>PTE</strong> (4 KiB leaf).DfIndex into the Page Table (derived from VA bits <code>[20:12]</code>).CcYou will write a <strong>PDE</strong> (2 MiB leaf).DkIndex into the Page Directory (derived from VA bits <code>[29:21]</code>\xe2\x80\xa6CeYou will write a <strong>PDPTE</strong> (1 GiB leaf).CjIndex into the PDPT (derived from virtual-address bits \xe2\x80\xa6CkIndex into the PML4 table (derived from virtual-address \xe2\x80\xa6BePage-size\xe2\x80\x93directed mapping behavior0AoMissing somewhere in the chain.Fg<strong>L2 PDE union</strong> \xe2\x80\x94 overlays non-leaf <code>Pde</code> and leaf <code>Pde2M</code> on \xe2\x80\xa6EkL3 <strong>PDPTE (1 GiB leaf)</strong> \xe2\x80\x94 maps a single 1 GiB page (<code>PS = 1</code>\xe2\x80\xa6AfDerive to generate \xe2\x80\xa6jBits: 0..1CiDeallocate a zeroed 4 KiB page suitable for a page-table.BiFetch the Graphics Output Protocol (GOP).BgReturns true if the frame is allocated.B`Leaf form: 1 GiB mapping (PS=1).B`Leaf form: 2 MiB mapping (PS=1).Chbytes to map from <code>vaddr_page</code> (page-rounded)FmMap <strong>one</strong> page at <code>va \xe2\x86\x92 pa</code> with size <code>S</code> and <code>leaf_flags</code>.CmIf present, return the mapped 4 KiB physical page and its \xe2\x80\xa6Co<strong>Present</strong> (P): valid entry if <code>true</code>.0A`Present (bit 0).0BdPresent (bit 0): valid entry if set.1Ce<strong>Present</strong> (bit 0): valid entry if set.2AfKernel Tracing helperslTrace outputE`Sets the provided <code>PageDirectory</code> at the specified <code>page</code>.ChZeroes the <code>PageDirectory</code> (PD) in this frameDlSets the provided <code>PageTable</code> at the specified <code>page</code>.CdZeroes the <code>PageTable</code> (PD) in this frameBfMarker trait for supported page sizes.CdThe PML4 root page for an <code>AddressSpace</code>.BlA tiny spinlock for short critical sections.Do<strong>Accessed</strong> (A): set by CPU on first access. Not a permission \xe2\x80\xa60AaAccessed (bit 5).000Dm<strong>Accessed</strong> (A, bit 5): set by CPU on first access via this \xe2\x80\xa61BjLoad CR3 with this address space\xe2\x80\x99s root.CgAllocate a zeroed 4 KiB page suitable for a page-table.ChReturn the index as <code>usize</code> for table access.0CjReturn the index as <code>usize</code> for array indexing.1C`Populate from an L2 <code>Pde</code> (non-leaf).BkDerive the PD index from a virtual address.BmDerive the PDPT index from a virtual address.CgDerive the <code>L4Index</code> from a virtual address.BkDerive the PT index from a virtual address.AnMemory Page Table Mapping SizeCjLength of the memory map buffer in <strong>bytes</strong>.CgPointer to the raw UEFI memory map buffer (array of \xe2\x80\xa6BePAT selector <strong>bit #2</strong>:0DiBorrow a <code>PageDirectoryPointerTable</code> (PDPT) located in the \xe2\x80\xa6DdBorrow a <code>PageDirectoryPointerTable</code> (PDPT) in this frameDkBorrow the <code>PageMapLevel4</code> (PML4) located in the given 4 KiB \xe2\x80\xa6CnBorrow the <code>PageMapLevel4</code> (PML4) as a typed table.CjMask of the red channel within a pixel (e.g., 0x00ff0000).FhInstall the <strong>leaf</strong> entry for <code>va \xe2\x86\x92 pa</code> in the <code>leaf_tbl_page</code> \xe2\x80\xa60DcSets the provided <code>PageDirectoryPointerTable</code> at the \xe2\x80\xa6E`Sets the provided <code>PageMapLevel4</code> at the specified <code>page</code>.jBits: 2..3mUser (bit 2).0BfUser (bit 2): user-mode access if set.1Dh<strong>User/Supervisor</strong> (bit 2): allow user-mode access if set.2CnSet the entry at <code>i</code> to <code>PdEntry::zero</code>.D`Set the entry at <code>i</code> to <code>PdptEntry::zero</code>.D`Set the entry at <code>i</code> to <code>PtEntry4k::zero</code>.BjEncode into <code>Pdpte</code> (non-leaf).BnEncode into <code>Pml4Entry</code> (non-leaf).Dc<strong>Writable</strong> (RW): allows writes if <code>true</code>.0AaWritable (bit 1).0BcWritable (bit 1): write permission.1Cd<strong>Writable</strong> (bit 1): write permission.2CmA simple Higher Half Direct Map (HHDM) base. Anything you \xe2\x80\xa60DfWhere you place the bytes in <em>physical</em> memory (LMA) before \xe2\x80\xa60C`The Page Table (L1): 512 entries, 4 KiB-aligned.Ff<strong>L3 PDPTE union</strong> \xe2\x80\x94 overlays non-leaf <code>Pdpte</code> and leaf <code>Pdpte1G</code>DdMap a physical region and return a <em>read-only</em> byte slice \xe2\x80\xa6FkL4 <strong>PML4E</strong> \xe2\x80\x94 pointer to a <strong>PDPT</strong> (non-leaf; PS <strong>must be 0</strong>).DoL1 <strong>PTE (4 KiB leaf)</strong> \xe2\x80\x94 maps a single 4 KiB page (bit 7 is \xe2\x80\xa6BiVirtual and Physical Memory Address TypesCkMask of the blue channel within a pixel (e.g., 0x000000ff).CfCreate from a raw value, aligning down to the page \xe2\x80\xa6BnConstruct from a full address\xe2\x80\x99s offset bits.CkConstruct union from raw <code>bits</code> (no validation).AbConvert from bits.0100000CkIf you already know the root frame (e.g., from your own \xe2\x80\xa6CbExtract raw <code>bits</code> back from the union.AbConvert into bits.0100000BfLoads a file from the EFI file system.AeMark a frame as free.BaMark a frame as used (allocated).Dn<strong>Page Size</strong> (bit 7): <strong>must be 1</strong> for 2 MiB leaf.Dn<strong>Page Size</strong> (bit 7): <strong>must be 1</strong> for 1 GiB leaf.Dk<strong>PAT</strong> (Page Attribute Table) selector for 2 MiB mappings \xe2\x80\xa6Dk<strong>PAT</strong> (Page Attribute Table) selector for 1 GiB mappings \xe2\x80\xa6Eh<strong>PAT</strong> (bit 7) \xe2\x80\x94 <strong>PAT selector bit 2</strong> for 4 KiB mappings.Bmpage-aligned physical base actually allocatedAjPhysical page of the PML4.ChRSDP (ACPI 2.0+) physical address, or 0 if not provided.Dk<strong>Dirty</strong> (bit 6): set by CPU on first write to this 2 MiB \xe2\x80\xa6Dk<strong>Dirty</strong> (bit 6): set by CPU on first write to this 1 GiB \xe2\x80\xa6BiDirty (bit 6): set by CPU on first write.jBits: 1..2iSpin LockBlEncode into <code>Pde2M</code> (2 MiB leaf).C`Encode into <code>PtEntry4k</code> (4 KiB leaf).AiUEFI Memory Map UtilitiesEfUnmap a single <strong>4 KiB</strong> page at <code>va</code>. Returns Err if missing.D`Execute <code>f</code> with exclusive access to the inner value.jBits: 2..3mUser (bit 2).0BfUser (bit 2): user-mode access if set.1Dh<strong>User/Supervisor</strong> (bit 2): allow user-mode access if set.2DcSets the provided <code>PageDirectoryPointerTable</code> at the \xe2\x80\xa6DfZeroes the <code>PageDirectoryPointerTable</code> (PDPT) in this frameE`Sets the provided <code>PageMapLevel4</code> at the specified <code>page</code>.DjMinimal allocator that hands out <strong>4 KiB</strong> page-table frames.D`A page base address (lower <code>S::SHIFT</code> bits are zero).ClMapper capable of temporarily viewing physical frames as \xe2\x80\xa6AkThe result of a table walk.BkAlign down to page boundary <code>S</code>.CnMask of the alpha channel within a pixel (often 0x00000000 \xe2\x80\xa6CbPopulate from an L3 <code>Pdpte</code> (non-leaf).CfPopulate from an L4 <code>Pml4Entry</code> (non-leaf).CcMask of the green channel within a pixel (e.g., \xe2\x80\xa6fErrorsDkGreedy region mapping: tiles <code>[virt_start .. virt_start+len)</code>\xe2\x80\xa6CjIf present, return the physical page of the next-level \xe2\x80\xa6Eg<strong>Execute Disable</strong> / NX: disallow instruction fetch if <code>true</code>.0AdNo-Execute (bit 63).000Cg<strong>No-Execute</strong> (NX, bit 63 / XD on Intel).1AaMemory Page TableDe<strong>Global</strong> (bit 8): TLB entry not flushed on CR3 reload.0CdGlobal (bit 8): TLB entry not flushed on CR3 reload.Bgpage-aligned VMA start used for mappingDk<strong>Dirty</strong> (bit 6): set by CPU on first write to this 2 MiB \xe2\x80\xa6Dk<strong>Dirty</strong> (bit 6): set by CPU on first write to this 1 GiB \xe2\x80\xa6BiDirty (bit 6): set by CPU on first write.jBits: 1..2ChWhere the kernel executes (VMA), matches your linker \xe2\x80\xa60DlHardware <strong>Present</strong> bit position shared across levels (bit 0).AaDecoded PDE kind.CaVirtual memory page base for size <code>S</code>.CbMinimal Bitmap-based Physical Memory Manager (PMM)AjKernel Framebuffer helpersAbGOP for the KernelCdPopulate from an L2 <code>Pde2M</code> (2 MiB leaf).ChPopulate from an L1 <code>PtEntry4k</code> (4 KiB leaf).AcSystem ACPI SupportnKernel HelpersChMain kernel loop, running with all memory (including \xe2\x80\xa6AcKernel QEMU HelpersBaKernel synchronization primitivesAfVirtual Memory SupportCiCreate from a raw value that must already be aligned. \xe2\x80\xa6CmParse a 64-bit little-endian x86-64 ELF image and collect \xe2\x80\xa6ClHHDM-based <code>PhysMapper</code> for Kernel Virtual MemoryDnMap a 4 KiB physical frame and get a <strong>mutable</strong> reference to \xe2\x80\xa6jBits: 0..1A`Present (bit 0).0BdPresent (bit 0): valid entry if set.1Ce<strong>Present</strong> (bit 0): valid entry if set.2BnEncode into <code>Pdpte1G</code> (1 GiB leaf).AlUEFI Loader Main Entry PointDe<strong>Global</strong> (bit 8): TLB entry not flushed on CR3 reload.0CdGlobal (bit 8): TLB entry not flushed on CR3 reload.BkHandle to a single, concrete address space.CkUEFI-backed frame allocator: hands out zeroed 4 KiB frames.CiTarget table/level produced by <code>ensure_chain</code>.CbPhysical memory page base for size <code>S</code>.DbChecked add of an offset, returning <code>None</code> on overflow.fSafetyDhView the <strong>currently active</strong> address space by reading CR3.BeKernel entry running on normal stack.CmBuild a PML4 entry that points to the given PDPT page and \xe2\x80\xa6DjCreate a new, present <code>PtEntry4k</code> with the specified flags, \xe2\x80\xa6AaAccessed (bit 5).000Dm<strong>Accessed</strong> (A, bit 5): set by CPU on first access via this \xe2\x80\xa61AaWritable (bit 1).0BcWritable (bit 1): write permission.1Cd<strong>Writable</strong> (bit 1): write permission.2ClGreedy unmap of a region: clears whole 1G/2M leaves when \xe2\x80\xa6jBits: 0..1A`Present (bit 0).0BdPresent (bit 0): valid entry if set.1Ce<strong>Present</strong> (bit 0): valid entry if set.2AhKernel function pointer.CcPrincipal raw memory address (virtual or physical).CdThe Page Directory (L2): 512 entries, 4 KiB-aligned.AnThe top-level page map (PML4).AhDecoded PDPT entry kind.ClMapper capable of temporarily viewing physical frames as \xe2\x80\xa6AfThe kernel entry pointBcAddress Space (x86-64, PML4-rooted)Df<strong>Page Cache Disable</strong> (PCD): disable caching (PAT bit1).0AfCache Disable (bit 4).000Di<strong>Page Cache Disable</strong> (PCD, bit 4): disable caching if set.CnCache Disable (bit 4) \xe2\x80\x94 <strong>PAT selector bit 1</strong>.CfPopulate from an L3 <code>Pdpte1G</code> (1 GiB leaf).BiNon-leaf PDE with common kernel RW flags.BeLeaf PDE with common kernel RW flags.BkNon-leaf PDPTE with common kernel RW flags.BgLeaf PDPTE with common kernel RW flags.AhGet the 2 MiB page base.BlGet the Page Directory base (4 KiB-aligned).AhGet the 1 GiB page base.AhGet the 4 KiB page base.DjReads the current value of the <strong>CR3 register</strong> (the page \xe2\x80\xa6Dn<strong>Page Size</strong> (bit 7): <strong>must be 1</strong> for 2 MiB leaf.Dn<strong>Page Size</strong> (bit 7): <strong>must be 1</strong> for 1 GiB leaf.Dk<strong>PAT</strong> (Page Attribute Table) selector for 2 MiB mappings \xe2\x80\xa6Dk<strong>PAT</strong> (Page Attribute Table) selector for 1 GiB mappings \xe2\x80\xa6Eh<strong>PAT</strong> (bit 7) \xe2\x80\x94 <strong>PAT selector bit 2</strong> for 4 KiB mappings.AaAccessed (bit 5).000Dm<strong>Accessed</strong> (A, bit 5): set by CPU on first access via this \xe2\x80\xa61AaWritable (bit 1).0BcWritable (bit 1): write permission.1Cd<strong>Writable</strong> (bit 1): write permission.2Dk<strong>Page Write-Through</strong> (PWT): write-through policy (PAT bit0).0AfWrite-Through (bit 3).000Dk<strong>Page Write-Through</strong> (PWT, bit 3): write-through caching \xe2\x80\xa6CnWrite-Through (bit 3) \xe2\x80\x94 <strong>PAT selector bit 0</strong>.FeBit masks for <code>BootPixelFormat::Bitmask</code>. For <code>Rgb</code>/<code>Bgr</code>, these \xe2\x80\xa6Di<code>PhysMapper</code> implementation for kernels with a higher-half \xe2\x80\xa6DkInformation the kernel needs right after <code>ExitBootServices</code>. \xe2\x80\xa6AgVirtual memory address.CmReturns the physical address of the RSDP if present, else \xe2\x80\xa6C`Size of a single memory descriptor in bytes (\xe2\x80\xa6Db4 KiB <strong>user RO+NX</strong> mapping (read-only, no execute).Cn<strong>Protection key</strong> (PKU) or OS-use (bits 59..62).0BaProtection Key / OS use (59..62).000Cg<strong>Protection Key / OS use</strong> (bits 59..62).1AdNo-Execute (bit 63).000Cg<strong>No-Execute</strong> (NX, bit 63 / XD on Intel).1Dn<strong>Page Size</strong> (bit 7): <strong>must be 1</strong> for 2 MiB leaf.Dn<strong>Page Size</strong> (bit 7): <strong>must be 1</strong> for 1 GiB leaf.Dk<strong>PAT</strong> (Page Attribute Table) selector for 2 MiB mappings \xe2\x80\xa6Dk<strong>PAT</strong> (Page Attribute Table) selector for 1 GiB mappings \xe2\x80\xa6Eh<strong>PAT</strong> (bit 7) \xe2\x80\x94 <strong>PAT selector bit 2</strong> for 4 KiB mappings.kStack size.ClPixel format tag compatible with UEFI GOP. We avoid Rust \xe2\x80\xa6AhPhysical memory address.CcVirtual offset inside the HHDM where we map the \xe2\x80\xa6CkLinear framebuffer base address (CPU physical address). \xe2\x80\xa6BlFetch an optimal framebuffer for the Kernel.Df<strong>Next-level table physical address</strong> (bits 12..51, 4 \xe2\x80\xa6CeNext-level table physical address (bits 12..51, 4 \xe2\x80\xa6Da<strong>Next-level table physical address</strong> (bits 12..51).DbPhysical address bits <strong>51:12</strong> (4 KiB-aligned base).DbPhysical address bits <strong>51:21</strong> (2 MiB-aligned base).DbPhysical address bits <strong>51:30</strong> (1 GiB-aligned base).AdNo-Execute (bit 63).000Cg<strong>No-Execute</strong> (NX, bit 63 / XD on Intel).1CiMinimal bitmap-based PMM for 4K frames in a fixed region.CfLoader mapper: treat low physical memory frames as \xe2\x80\xa6DiEnsure that the non-leaf chain for <code>va</code> exists down to the \xe2\x80\xa60DlTotal framebuffer size in <strong>bytes</strong>. Helpful for bounds checks.Eh<strong>OS-available (low)</strong>: bits 9..11 (masked to 3 bits in <code>to_*</code>).0AnOS-available low (bits 9..11).000Dl<strong>OS-available low</strong> (bits 9..11): not interpreted by hardware.1AhGet the Page Table base.BjGet the PDPT base address (4 KiB-aligned).jBits: 2..3mUser (bit 2).0BfUser (bit 2): user-mode access if set.1Dh<strong>User/Supervisor</strong> (bit 2): allow user-mode access if set.2BgEnter the kernel via a tiny trampoline.CiA UEFI Boot Services pool allocation to back Rust\xe2\x80\x99s \xe2\x80\xa6BiPixel bit masks (only meaningful when \xe2\x80\xa6BiVisible width in <strong>pixels</strong>.CgDescriptor version (from UEFI). Kernel can check it \xe2\x80\xa6Ek<strong>OS-available (high)</strong>: bits 52..58 (masked to 7 bits in <code>to_*</code>\xe2\x80\xa60B`OS-available high (bits 52..58).000Dh<strong>OS-available high</strong> (bits 52..58): not interpreted by \xe2\x80\xa61DkCreate a new, present <code>PdEntry</code> with the specified flags, at \xe2\x80\xa6BnCreate a 1 GiB leaf PDPTE (<code>PS=1</code>).DfCreate a non-leaf PDE that points to a Page Table (<code>PS=0</code>).ClCreate a non-leaf PDPTE that points to a Page Directory (\xe2\x80\xa6CjRemaps the boot framebuffer memory into the kernel\xe2\x80\x99s \xe2\x80\xa6AfCache Disable (bit 4).000Di<strong>Page Cache Disable</strong> (PCD, bit 4): disable caching if set.CnCache Disable (bit 4) \xe2\x80\x94 <strong>PAT selector bit 1</strong>.Dk<strong>Dirty</strong> (bit 6): set by CPU on first write to this 2 MiB \xe2\x80\xa6Dk<strong>Dirty</strong> (bit 6): set by CPU on first write to this 1 GiB \xe2\x80\xa6BiDirty (bit 6): set by CPU on first write.BhSet the Page Table base (4 KiB-aligned).C`Set the 2 MiB page base (must be 2 MiB-aligned).BlSet the Page Directory base (4 KiB-aligned).C`Set the 1 GiB page base (must be 1 GiB-aligned).BhSet the 4 KiB page base (4 KiB-aligned).jBits: 1..2AfWrite-Through (bit 3).000Dk<strong>Page Write-Through</strong> (PWT, bit 3): write-through caching \xe2\x80\xa6CnWrite-Through (bit 3) \xe2\x80\x94 <strong>PAT selector bit 0</strong>.jBits: 2..3mUser (bit 2).0BfUser (bit 2): user-mode access if set.1Dh<strong>User/Supervisor</strong> (bit 2): allow user-mode access if set.2CnKeep a tiny identity map so the paging switch code remains \xe2\x80\xa60CnExist the UEFI boot services and retain a copy of the UEFI \xe2\x80\xa6DhPixel format tag (Rgb/Bgr/Bitmask/BltOnly). If <code>BltOnly</code>, \xe2\x80\xa6BjVisible height in <strong>pixels</strong>.CoPixels per scanline (a.k.a. stride). May be &gt;= width due \xe2\x80\xa6De<strong>Global</strong> (bit 8): TLB entry not flushed on CR3 reload.0CdGlobal (bit 8): TLB entry not flushed on CR3 reload.BaProtection Key / OS use (59..62).000Cg<strong>Protection Key / OS use</strong> (bits 59..62).1AfCache Disable (bit 4).000Di<strong>Page Cache Disable</strong> (PCD, bit 4): disable caching if set.CnCache Disable (bit 4) \xe2\x80\x94 <strong>PAT selector bit 1</strong>.Dk<strong>Dirty</strong> (bit 6): set by CPU on first write to this 2 MiB \xe2\x80\xa6Dk<strong>Dirty</strong> (bit 6): set by CPU on first write to this 1 GiB \xe2\x80\xa6BiDirty (bit 6): set by CPU on first write.BhSet the Page Table base (4 KiB-aligned).C`Set the 2 MiB page base (must be 2 MiB-aligned).BlSet the Page Directory base (4 KiB-aligned).C`Set the 1 GiB page base (must be 1 GiB-aligned).BhSet the 4 KiB page base (4 KiB-aligned).jBits: 1..2AfWrite-Through (bit 3).000Dk<strong>Page Write-Through</strong> (PWT, bit 3): write-through caching \xe2\x80\xa6CnWrite-Through (bit 3) \xe2\x80\x94 <strong>PAT selector bit 0</strong>.DlThe offset within a page of size <code>S</code> (<code>0..S::SIZE-1</code>).jBits: 0..1Df<strong>Next-level table physical address</strong> (bits 12..51, 4 \xe2\x80\xa6CeNext-level table physical address (bits 12..51, 4 \xe2\x80\xa6Da<strong>Next-level table physical address</strong> (bits 12..51).DbPhysical address bits <strong>51:12</strong> (4 KiB-aligned base).DbPhysical address bits <strong>51:21</strong> (2 MiB-aligned base).DbPhysical address bits <strong>51:30</strong> (1 GiB-aligned base).A`Present (bit 0).0BdPresent (bit 0): valid entry if set.1Ce<strong>Present</strong> (bit 0): valid entry if set.2De<strong>Global</strong> (bit 8): TLB entry not flushed on CR3 reload.0CdGlobal (bit 8): TLB entry not flushed on CR3 reload.BaProtection Key / OS use (59..62).000Cg<strong>Protection Key / OS use</strong> (bits 59..62).1CfAllocate a buffer to hold a copy of the memory map \xe2\x80\xa6AaAccessed (bit 5).000Dm<strong>Accessed</strong> (A, bit 5): set by CPU on first access via this \xe2\x80\xa61AnOS-available low (bits 9..11).000Dl<strong>OS-available low</strong> (bits 9..11): not interpreted by hardware.1CbSet the PDPT base address (must be 4 KiB-aligned).AaWritable (bit 1).0BcWritable (bit 1): write permission.1Cd<strong>Writable</strong> (bit 1): write permission.2jBits: 0..1Df<strong>Next-level table physical address</strong> (bits 12..51, 4 \xe2\x80\xa6CeNext-level table physical address (bits 12..51, 4 \xe2\x80\xa6Da<strong>Next-level table physical address</strong> (bits 12..51).DbPhysical address bits <strong>51:12</strong> (4 KiB-aligned base).DbPhysical address bits <strong>51:21</strong> (2 MiB-aligned base).DbPhysical address bits <strong>51:30</strong> (1 GiB-aligned base).A`Present (bit 0).0BdPresent (bit 0): valid entry if set.1Ce<strong>Present</strong> (bit 0): valid entry if set.2BnEnable write-combining (WC) via PAT registers.CkUnified, ergonomic view over x86-64 paging entries (all \xe2\x80\xa60CmWalks the whole tree and frees empty tables (PT/PD/PDPT). \xe2\x80\xa6B`OS-available high (bits 52..58).000Dh<strong>OS-available high</strong> (bits 52..58): not interpreted by \xe2\x80\xa61Dn<strong>Page Size</strong> (bit 7): <strong>must be 1</strong> for 2 MiB leaf.Dn<strong>Page Size</strong> (bit 7): <strong>must be 1</strong> for 1 GiB leaf.Dk<strong>PAT</strong> (Page Attribute Table) selector for 2 MiB mappings \xe2\x80\xa6Dk<strong>PAT</strong> (Page Attribute Table) selector for 1 GiB mappings \xe2\x80\xa6Eh<strong>PAT</strong> (bit 7) \xe2\x80\x94 <strong>PAT selector bit 2</strong> for 4 KiB mappings.AaAccessed (bit 5).000Dm<strong>Accessed</strong> (A, bit 5): set by CPU on first access via this \xe2\x80\xa61AnOS-available low (bits 9..11).000Dl<strong>OS-available low</strong> (bits 9..11): not interpreted by hardware.1CbSet the PDPT base address (must be 4 KiB-aligned).AaWritable (bit 1).0BcWritable (bit 1): write permission.1Cd<strong>Writable</strong> (bit 1): write permission.2CnAllocate a trampoline stack (optionally with a guard page) \xe2\x80\xa6AdNo-Execute (bit 63).000Cg<strong>No-Execute</strong> (NX, bit 63 / XD on Intel).1oAccessor DeriveB`OS-available high (bits 52..58).000Dh<strong>OS-available high</strong> (bits 52..58): not interpreted by \xe2\x80\xa61Dn<strong>Page Size</strong> (bit 7): <strong>must be 1</strong> for 2 MiB leaf.Dn<strong>Page Size</strong> (bit 7): <strong>must be 1</strong> for 1 GiB leaf.Dk<strong>PAT</strong> (Page Attribute Table) selector for 2 MiB mappings \xe2\x80\xa6Dk<strong>PAT</strong> (Page Attribute Table) selector for 1 GiB mappings \xe2\x80\xa6Eh<strong>PAT</strong> (bit 7) \xe2\x80\x94 <strong>PAT selector bit 2</strong> for 4 KiB mappings.A`A mapping error.DaError returned by <code>MapSize::ensure_chain_for</code> when \xe2\x80\xa6;;;;:;EiLoad all <code>PT_LOAD</code> segments at their <strong>physical LMA</strong> derived \xe2\x80\xa6C`The PDPT (L3) table: 512 entries, 4 KiB aligned.AfCache Disable (bit 4).000Di<strong>Page Cache Disable</strong> (PCD, bit 4): disable caching if set.CnCache Disable (bit 4) \xe2\x80\x94 <strong>PAT selector bit 1</strong>.AfWrite-Through (bit 3).000Dk<strong>Page Write-Through</strong> (PWT, bit 3): write-through caching \xe2\x80\xa6CnWrite-Through (bit 3) \xe2\x80\x94 <strong>PAT selector bit 0</strong>.9BaProtection Key / OS use (59..62).000Cg<strong>Protection Key / OS use</strong> (bits 59..62).1777765444432CmAddress arithmetic overflow while mapping trampoline code \xe2\x80\xa6Df<strong>Next-level table physical address</strong> (bits 12..51, 4 \xe2\x80\xa6CeNext-level table physical address (bits 12..51, 4 \xe2\x80\xa6Da<strong>Next-level table physical address</strong> (bits 12..51).DbPhysical address bits <strong>51:12</strong> (4 KiB-aligned base).DbPhysical address bits <strong>51:21</strong> (2 MiB-aligned base).DbPhysical address bits <strong>51:30</strong> (1 GiB-aligned base).888878CnAddress arithmetic overflow while mapping trampoline stack \xe2\x80\xa6AnOS-available low (bits 9..11).000Dl<strong>OS-available low</strong> (bits 9..11): not interpreted by hardware.1876543B`OS-available high (bits 52..58).000Dh<strong>OS-available high</strong> (bits 52..58): not interpreted by \xe2\x80\xa61333323111101")